(* Nel nuovo comando: la dichiarazione e l'assegnamento vengono fatti prima di passare il comando al blocco (permette di risparmiare un passo a chiamata) *)
| Call(identifier,Var(x)) -> (match topenv state identifier with        (* Guardiamo a cosa è associato l'identificatore *)
        IProc(Val(y),command') -> (match ((topenv state) x) with            (* Se è una procedura, controlliamo a cosa è associato il parametro (variabile) in ingresso *)
            IVar(location) -> let value = (getmem state) location in        (* Recuperiamo dalla memoria il valore della variabile *)
              Cmd(Block(Var(y),Seq(Assign(y,Const(value)),command')),state) (* Passiamo il comando al blocco che assocerà il parametro attuale a quello formale *)
          | _ -> failwith (x ^ " is not a variable.")
        )

(* Nel nuovo comando: la dichiarazione e l'assegnamento vengono fatti prima di passare il comando al blocco (permette di risparmiare un passo a chiamata) *)
| Call(identifier,Const(n)) -> (match (topenv state) identifier with (* Controlla a cosa corrisponde nell'ambiente l'identificatore *)
          IProc(Val(x),command') -> Cmd(Block(Var(x),Seq(Assign(x,Const(n)),command')),state)
        | _ -> failwith(identifier ^ " accepts only referred parameters.")
    )
